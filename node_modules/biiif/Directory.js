"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Canvas_1 = require("./Canvas");
const path_1 = require("path");
const glob_promise_1 = require("glob-promise");
const url_1 = require("url");
const Utils_1 = require("./Utils");
const chalk_1 = __importDefault(require("chalk"));
const url_join_1 = __importDefault(require("url-join"));
// boilerplate json
const canvasBoilerplate = require("./boilerplate/canvas.json");
const collection_json_1 = __importDefault(require("./boilerplate/collection.json"));
const collectionitem_json_1 = __importDefault(require("./boilerplate/collectionitem.json"));
const manifest_json_1 = __importDefault(require("./boilerplate/manifest.json"));
const manifestitem_json_1 = __importDefault(require("./boilerplate/manifestitem.json"));
const thumbnail_json_1 = __importDefault(require("./boilerplate/thumbnail.json"));
class Directory {
    constructor(directoryPath, url, generateThumbs = false, virtualName, parentDirectory) {
        this.directories = [];
        this.items = [];
        this.directoryPath = directoryPath;
        this.generateThumbs = generateThumbs;
        this.url = new url_1.URL(url);
        this.parentDirectory = parentDirectory;
        this.virtualName = virtualName;
    }
    async read() {
        // canvases are directories starting with an underscore
        const canvasesPattern = this.directoryPath + '/_*';
        const canvases = await glob_promise_1.promise(canvasesPattern, {
            ignore: [
                '**/*.yml',
                '**/thumb.*'
            ]
        });
        // sort canvases 
        canvases.sort((a, b) => {
            return Utils_1.Utils.compare(a, b);
        });
        await Promise.all(canvases.map(async (canvas) => {
            console.log(chalk_1.default.green('creating canvas for: ') + canvas);
            this.items.push(new Canvas_1.Canvas(canvas, this));
        }));
        // directories not starting with an underscore
        // these can be child manifests or child collections
        const directoriesPattern = this.directoryPath + '/*';
        const directories = await glob_promise_1.promise(directoriesPattern, {
            ignore: [
                '**/*.{crt,drc,glb,gltf,gz,stl,jpg,jpeg,json,mp3,mp4,nii,obj,pdf,ply,png,yml}',
                '**/_*' // ignore canvas folders
            ]
        });
        // sort canvases 
        directories.sort((a, b) => {
            return Utils_1.Utils.compare(a, b);
        });
        await Promise.all(directories.map(async (directory) => {
            console.log(chalk_1.default.green('creating directory for: ') + directory);
            const name = path_1.basename(directory);
            const url = url_join_1.default(this.url.href, name);
            const newDirectory = new Directory(directory, url, this.generateThumbs, undefined, this);
            await newDirectory.read();
            this.directories.push(newDirectory);
        }));
        // if there are no canvas, manifest, or collection directories to read,
        // but there are paintable files in the current directory,
        // create a canvas for each.
        if (!this.directories.length && !canvases.length) {
            const paintableFiles = await glob_promise_1.promise(this.directoryPath + '/*.*', {
                ignore: [
                    '**/*.yml',
                    '**/thumb.*',
                    '**/index.json'
                ]
            });
            // sort files 
            paintableFiles.sort((a, b) => {
                return Utils_1.Utils.compare(a, b);
            });
            paintableFiles.forEach((file) => {
                console.log(chalk_1.default.green('creating canvas for: ') + file);
                this.items.push(new Canvas_1.Canvas(file, this));
            });
        }
        this.isCollection = this.directories.length > 0 || await Utils_1.Utils.hasManifestsYml(this.directoryPath);
        await this._getInfo();
        await this._createIndexJson();
        if (this.isCollection) {
            console.log(chalk_1.default.green('created collection: ') + this.directoryPath);
            // if there are canvases, warn that they are being ignored
            if (this.items.length) {
                console.warn(chalk_1.default.yellow(this.items.length + ' unused canvas directories (starting with an underscore) found in the ' + this.directoryPath + ' collection. Remove directories not starting with an underscore to convert into a manifest.'));
            }
        }
        else {
            console.log(chalk_1.default.green('created manifest: ') + this.directoryPath);
            // if there aren't any canvases, warn that there should be
            if (!this.items.length) {
                console.warn(chalk_1.default.yellow(this.directoryPath + ' is a manifest, but no canvases (directories starting with an underscore) were found. Therefore it will not have any content.'));
            }
        }
    }
    async _getInfo() {
        this.infoYml = {};
        // if there's an info.yml
        const ymlPath = path_1.join(this.directoryPath, 'info.yml');
        const fileExists = await Utils_1.Utils.fileExists(ymlPath);
        if (fileExists) {
            this.infoYml = await Utils_1.Utils.readYml(ymlPath);
            console.log(chalk_1.default.green('got metadata for: ') + this.directoryPath);
        }
        else {
            console.log(chalk_1.default.green('no metadata found for: ') + this.directoryPath);
        }
        if (!this.infoYml.label) {
            // default to the directory name
            this.infoYml.label = path_1.basename(this.directoryPath);
        }
    }
    async _createIndexJson() {
        if (this.isCollection) {
            this.indexJson = Utils_1.Utils.cloneJson(collection_json_1.default);
            // for each child directory, add a collectionitem or manifestitem json boilerplate to items.
            await Promise.all(this.directories.map(async (directory) => {
                let itemJson;
                if (directory.isCollection) {
                    itemJson = Utils_1.Utils.cloneJson(collectionitem_json_1.default);
                }
                else {
                    itemJson = Utils_1.Utils.cloneJson(manifestitem_json_1.default);
                }
                itemJson.id = url_join_1.default(directory.url.href, 'index.json');
                itemJson.label = Utils_1.Utils.getLabel(directory.infoYml.label);
                await Utils_1.Utils.getThumbnail(itemJson, directory);
                this.indexJson.items.push(itemJson);
            }));
            // check for manifests.yml. if it exists, parse and add to items
            const hasManifestsYml = await Utils_1.Utils.hasManifestsYml(this.directoryPath);
            if (hasManifestsYml) {
                const manifestsPath = path_1.join(this.directoryPath, 'manifests.yml');
                const manifestsYml = await Utils_1.Utils.readYml(manifestsPath);
                manifestsYml.manifests.forEach((manifest) => {
                    const itemJson = Utils_1.Utils.cloneJson(collectionitem_json_1.default);
                    itemJson.id = manifest.id;
                    if (manifest.label) {
                        itemJson.label = Utils_1.Utils.getLabel(manifest.label);
                    }
                    else {
                        // no label supplied, use the last fragment of the url
                        const url = new url_1.URL(itemJson.id);
                        const pathname = url.pathname.split('/');
                        if (pathname.length > 1) {
                            itemJson.label = Utils_1.Utils.getLabel(pathname[pathname.length - 2]);
                        }
                    }
                    if (manifest.thumbnail) {
                        if (typeof manifest.thumbnail === 'string') {
                            const thumbnail = Utils_1.Utils.cloneJson(thumbnail_json_1.default);
                            thumbnail[0].id = manifest.thumbnail;
                            itemJson.thumbnail = thumbnail;
                        }
                        else {
                            itemJson.thumbnail = manifest.thumbnail;
                        }
                    }
                    this.indexJson.items.push(itemJson);
                });
                console.log(chalk_1.default.green('parsed manifests.yml for: ') + this.directoryPath);
            }
            else {
                console.log(chalk_1.default.green('no manifests.yml found for: ') + this.directoryPath);
            }
            // sort items 
            this.indexJson.items.sort((a, b) => {
                return Utils_1.Utils.compare(a.label['@none'][0].toLowerCase(), b.label['@none'][0].toLowerCase());
            });
        }
        else {
            this.indexJson = Utils_1.Utils.cloneJson(manifest_json_1.default);
            // for each canvas, add canvas json
            let index = 0;
            for (const canvas of this.items) {
                const canvasJson = Utils_1.Utils.cloneJson(canvasBoilerplate);
                canvasJson.id = url_join_1.default(this.url.href, 'index.json/canvas', index);
                canvasJson.items[0].id = url_join_1.default(this.url.href, 'index.json/canvas', index, 'annotationpage/0');
                await canvas.read(canvasJson);
                // add canvas to items
                this.indexJson.items.push(canvasJson);
                index++;
            }
            this.indexJson.items.sort((a, b) => {
                return Utils_1.Utils.compare(a.id, b.id);
            });
        }
        this.indexJson.id = url_join_1.default(this.url.href, 'index.json');
        this._applyInfo();
        await Utils_1.Utils.getThumbnail(this.indexJson, this);
        // write index.json
        const path = path_1.join(this.directoryPath, 'index.json');
        const json = JSON.stringify(this.indexJson, null, '  ');
        console.log(chalk_1.default.green('creating index.json for: ') + this.directoryPath);
        await Utils_1.Utils.writeJson(path, json);
    }
    _applyInfo() {
        this.indexJson.label = Utils_1.Utils.getLabel(this.infoYml.label); // defaults to directory name
        if (this.infoYml.metadata) {
            this.indexJson.metadata = Utils_1.Utils.formatMetadata(this.infoYml.metadata);
        }
        // add manifest-specific properties
        if (!this.isCollection) {
            if (this.infoYml.attribution) {
                this.indexJson.attribution = this.infoYml.attribution;
            }
            if (this.infoYml.description) {
                this.indexJson.description = this.infoYml.description;
            }
            if (this.infoYml.behavior) {
                this.indexJson.behavior = [];
                if (Array.isArray(this.infoYml.behavior)) {
                    this.infoYml.behavior.forEach(behavior => {
                        this.indexJson.behavior.push(behavior);
                    });
                }
                else {
                    this.indexJson.behavior.push(this.infoYml.behavior);
                }
            }
        }
    }
}
exports.Directory = Directory;
