"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const dist_commonjs_1 = require("@iiif/vocabulary/dist-commonjs/");
const path_1 = require("path");
const path_2 = require("path");
const glob_promise_1 = require("glob-promise");
const chalk_1 = __importDefault(require("chalk"));
const config_json_1 = __importDefault(require("./config.json"));
const ffprobe_1 = __importDefault(require("ffprobe"));
const ffprobe_static_1 = __importDefault(require("ffprobe-static"));
const fs_1 = __importDefault(require("fs"));
const is_url_1 = __importDefault(require("is-url"));
const jimp_1 = __importDefault(require("jimp"));
const jsonfile_1 = __importDefault(require("jsonfile"));
const label_json_1 = __importDefault(require("./boilerplate/label.json"));
const thumbnail_json_1 = __importDefault(require("./boilerplate/thumbnail.json"));
const url_join_1 = __importDefault(require("url-join"));
const js_yaml_1 = __importDefault(require("js-yaml"));
class Utils {
    static compare(a, b) {
        const collator = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' });
        return collator.compare(a, b);
    }
    static normaliseType(type) {
        type = type.toLowerCase();
        if (type.indexOf(':') !== -1) {
            const split = type.split(':');
            return split[1];
        }
        return type;
    }
    static getTypeByExtension(motivation, extension) {
        motivation = Utils.normaliseType(motivation);
        const m = this._config.annotation.motivations[motivation];
        if (m) {
            if (m[extension] && m[extension].length) {
                return m[extension][0].type;
            }
        }
        return null;
    }
    static getFormatByExtension(motivation, extension) {
        motivation = Utils.normaliseType(motivation);
        const m = this._config.annotation.motivations[motivation];
        if (m) {
            if (m[extension] && m[extension].length) {
                return m[extension][0].format;
            }
        }
        return null;
    }
    static getFormatByExtensionAndType(motivation, extension, type) {
        motivation = Utils.normaliseType(motivation);
        const m = this._config.annotation.motivations[motivation];
        if (m) {
            if (m[extension] && m[extension].length) {
                const typeformats = m[extension];
                for (let i = 0; i < typeformats.length; i++) {
                    const typeformat = typeformats[i];
                    if (typeformat.type === type) {
                        return typeformat.format;
                    }
                }
            }
        }
        return null;
    }
    static getTypeByFormat(motivation, format) {
        motivation = Utils.normaliseType(motivation);
        const m = this._config.annotation.motivations[motivation];
        if (m) {
            for (const extension in m) {
                const typeformats = m[extension];
                for (let i = 0; i < typeformats.length; i++) {
                    const typeformat = typeformats[i];
                    if (typeformat.format === format) {
                        return typeformat.type;
                    }
                }
            }
        }
        return null;
    }
    static getFormatByType(motivation, type) {
        motivation = Utils.normaliseType(motivation);
        const m = this._config.annotation.motivations[motivation];
        // only able to categorically say there's a matching format 
        // if there's a single extension with a single type
        if (m) {
            if (Object.keys(m).length === 1) {
                const typeformats = m[Object.keys(m)[0]];
                if (typeformats.length === 1) {
                    return typeformats[0].format;
                }
            }
        }
        return null;
    }
    static timeout(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    static cloneJson(json) {
        return JSON.parse(JSON.stringify(json));
    }
    static formatMetadata(metadata) {
        const formattedMetadata = [];
        for (let key in metadata) {
            if (metadata.hasOwnProperty(key)) {
                const value = metadata[key];
                const item = {};
                item.label = Utils.getLabel(key);
                item.value = Utils.getLabel(value);
                formattedMetadata.push(item);
            }
        }
        return formattedMetadata;
    }
    // If filePath is:
    // C://Users/edsilv/github/edsilv/biiif-workshop/collection/_abyssinian/thumb.jpeg
    // and 'collection' has been replaced by the top-level virtual name 'virtualname'
    // it should return:
    // C://Users/edsilv/github/edsilv/biiif-workshop/virtualname/_abyssinian/thumb.jpeg
    // virtual names are needed when using dat or ipfs ids as the root directory.
    static getVirtualFilePath(filePath, directory) {
        // walk up directory parents building the realPath and virtualPath array as we go.
        // at the top level directory, use the real name for realPath and the virtual name for virtualPath.
        // reverse the arrays and join with a '/'.
        // replace the realPath section of filePath with virtualPath.
        let realPath = [path_2.basename(filePath)];
        let virtualPath = [path_2.basename(filePath)];
        while (directory) {
            const realName = path_2.basename(directory.directoryPath);
            const virtualName = directory.virtualName || realName;
            realPath.push(realName);
            virtualPath.push(virtualName);
            directory = directory.parentDirectory;
        }
        realPath = realPath.reverse();
        virtualPath = virtualPath.reverse();
        const realPathString = realPath.join('/');
        const virtualPathString = virtualPath.join('/');
        filePath = Utils.normaliseFilePath(filePath);
        filePath = filePath.replace(realPathString, virtualPathString);
        return filePath;
    }
    static isJsonFile(path) {
        return path_1.extname(path) === '.json';
    }
    static isDirectory(path) {
        return fs_1.default.lstatSync(path).isDirectory();
    }
    static async getThumbnail(json, directory, filePath) {
        let fp = filePath || directory.directoryPath;
        fp = Utils.normaliseFilePath(fp);
        const thumbnailPattern = fp + '/thumb.*';
        const thumbnails = await glob_promise_1.promise(thumbnailPattern);
        if (thumbnails.length) {
            // there's alrady a thumbnail in the directory, add it to the canvas
            console.log(chalk_1.default.green('found thumbnail for: ') + fp);
            let thumbnail = thumbnails[0];
            const thumbnailJson = Utils.cloneJson(thumbnail_json_1.default);
            thumbnailJson[0].id = Utils.mergePaths(directory.url, Utils.getVirtualFilePath(thumbnail, directory));
            json.thumbnail = thumbnailJson;
        }
        else if (directory.generateThumbs) {
            // there isn't a thumbnail in the directory, so we'll need to generate it.
            // if debugging: jimp item.getitem is not a function
            // generate thumbnail
            if (json.items && json.items.length && json.items[0].items) {
                // find an annotation with a painting motivation of type image.
                const items = json.items[0].items;
                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    const body = item.body;
                    if (body && item.motivation === Utils.normaliseType(dist_commonjs_1.AnnotationMotivation.PAINTING)) {
                        // is it an image? (without an info.json)
                        if (body.type.toLowerCase() === dist_commonjs_1.ExternalResourceType.IMAGE && !Utils.isJsonFile(body.id)) {
                            let imageName = body.id.substr(body.id.lastIndexOf('/'));
                            if (imageName.includes('#')) {
                                imageName = imageName.substr(0, imageName.lastIndexOf('#'));
                            }
                            const imagePath = Utils.normaliseFilePath(path_2.join(fp, imageName));
                            let pathToThumb = Utils.normaliseFilePath(path_2.join(path_1.dirname(imagePath), 'thumb.'));
                            // todo: this currently assumes that the image to generate a thumb from is within the directory, 
                            // but it may be in an assets folder and painted by a custom annotation.
                            // see canvas-with-dimensions-manifest.js
                            if (this._config.settings.jimpEnabled && await Utils.fileExists(imagePath)) {
                                const image = await jimp_1.default.read(imagePath);
                                const thumb = image.clone();
                                // write image buffer to disk for testing
                                // image.getBuffer(Jimp.AUTO, (err, buffer) => {
                                //     const arrBuffer = [...buffer];
                                //     const pathToBuffer: string = imagePath.substr(0, imagePath.lastIndexOf('/')) + '/buffer.txt';
                                //     fs.writeFile(pathToBuffer, arrBuffer);
                                // });
                                //thumb.cover(this._config.thumbnails.width, this._config.thumbnails.height);
                                thumb.resize(this._config.thumbnails.width, jimp_1.default.AUTO);
                                pathToThumb += image.getExtension();
                                // a thumbnail may already exist at this path (when generating from a flat collection of images)
                                const thumbExists = await Utils.fileExists(pathToThumb);
                                if (!thumbExists) {
                                    thumb.write(pathToThumb, () => {
                                        console.log(chalk_1.default.green('generated thumbnail for: ') + fp);
                                    });
                                }
                                else {
                                    console.log(chalk_1.default.green('found thumbnail for: ') + fp);
                                }
                            }
                            else {
                                // placeholder img path
                                pathToThumb += "jpeg";
                            }
                            const thumbnailJson = Utils.cloneJson(thumbnail_json_1.default);
                            const virtualPath = Utils.getVirtualFilePath(pathToThumb, directory);
                            const mergedPath = Utils.mergePaths(directory.url, virtualPath);
                            thumbnailJson[0].id = mergedPath;
                            json.thumbnail = thumbnailJson;
                        }
                    }
                }
            }
        }
    }
    static getLabel(value) {
        const labelJson = Utils.cloneJson(label_json_1.default);
        labelJson['@none'].push(value);
        return labelJson;
    }
    static async getFileDimensions(type, file, canvasJson, annotationJson) {
        console.log(chalk_1.default.green('getting file dimensions for: ') + file);
        if (!Utils.isJsonFile(file)) {
            switch (type.toLowerCase()) {
                // if it's an image, get the width and height and add to the annotation body and canvas
                case dist_commonjs_1.ExternalResourceType.IMAGE:
                    const image = await jimp_1.default.read(file);
                    const width = image.bitmap.width;
                    const height = image.bitmap.height;
                    canvasJson.width = Math.max(canvasJson.width || 0, width);
                    canvasJson.height = Math.max(canvasJson.height || 0, height);
                    annotationJson.body.width = width;
                    annotationJson.body.height = height;
                    break;
                // if it's a sound, get the duration and add to the canvas
                case dist_commonjs_1.ExternalResourceType.SOUND:
                case dist_commonjs_1.ExternalResourceType.VIDEO:
                    try {
                        const info = await ffprobe_1.default(file, { path: ffprobe_static_1.default.path });
                        if (info && info.streams && info.streams.length) {
                            const duration = Number(info.streams[0].duration);
                            canvasJson.duration = duration;
                        }
                    }
                    catch (_a) {
                        console.warn(`ffprobe couldn't load ${file}`);
                    }
                    break;
            }
        }
    }
    /*
        merge these two example paths:
        url:        http://test.com/collection/manifest
        filePath:   c:/user/documents/collection/manifest/_canvas/thumb.png

        into:       http://test.com/collection/manifest/_canvas/thumb.png
    */
    static mergePaths(url, filePath) {
        // split the url (minus origin) and filePath into arrays
        //                            ['collection', 'manifest']
        // ['c:', 'user', 'documents', 'collection', 'manifest', '_canvas', 'thumb.jpg']
        // walk backwards through the filePath array adding to the newPath array until the last item of the url array is found.
        // then while the next url item matches the next filePath item, add it to newPath.
        // the final path is the url origin plus a reversed newPath joined with a '/'
        let origin = url.origin;
        if (url.protocol === 'dat:') {
            origin = 'dat://';
        }
        const urlParts = Utils.getUrlParts(url);
        filePath = Utils.normaliseFilePath(filePath);
        const fileParts = filePath.split('/');
        let newPath = [];
        // if there's a single root folder and none of the file path matches
        if (urlParts.length === 1 && !fileParts.includes(urlParts[0])) {
            newPath.push(fileParts[fileParts.length - 1]);
            newPath.push(urlParts[0]);
        }
        else {
            for (let f = fileParts.length - 1; f >= 0; f--) {
                const filePart = fileParts[f];
                newPath.push(filePart);
                if (filePart === urlParts[urlParts.length - 1]) {
                    if (urlParts.length > 1) {
                        for (let u = urlParts.length - 2; u >= 0; u--) {
                            f--;
                            if (fileParts[f] === urlParts[u]) {
                                newPath.push(fileParts[f]);
                            }
                            else {
                                newPath.push(urlParts[u]);
                            }
                        }
                    }
                    break;
                }
            }
        }
        let id = url_join_1.default(origin, ...newPath.reverse());
        return id;
    }
    static normaliseFilePath(filePath) {
        return filePath.replace(/\\/g, '/').replace(/\/\//g, '/');
    }
    static getUrlParts(url) {
        let origin = url.origin;
        let urlParts;
        let href = url.href;
        if (href.endsWith('/')) {
            href = href.slice(0, -1);
        }
        if (url.protocol === 'dat:') {
            origin = 'dat://';
            urlParts = href.replace(origin, '').split('/');
        }
        else {
            urlParts = href.replace(origin + '/', '').split('/');
        }
        return urlParts;
    }
    static async readJson(path) {
        return new Promise((resolve, reject) => {
            jsonfile_1.default.readFile(path, (err, json) => {
                if (err)
                    reject(err);
                else
                    resolve(json);
            });
        });
    }
    static async writeJson(path, json) {
        return new Promise((resolve, reject) => {
            fs_1.default.writeFile(path, json, (err) => {
                if (err)
                    reject(err);
                else
                    resolve();
            });
        });
    }
    static async readYml(path) {
        return new Promise((resolve, reject) => {
            fs_1.default.readFile(path, (err, fileBuffer) => {
                if (err) {
                    reject(err);
                }
                else {
                    const yml = js_yaml_1.default.safeLoad(fileBuffer);
                    resolve(yml);
                }
            });
        });
    }
    static async fileExists(path) {
        return new Promise((resolve, reject) => {
            const exists = fs_1.default.existsSync(path);
            resolve(exists);
        });
    }
    static async hasManifestsYml(path) {
        return new Promise((resolve, reject) => {
            const manifestsPath = path_2.join(path, 'manifests.yml');
            Utils.fileExists(manifestsPath).then((exists) => {
                resolve(exists);
            });
        });
    }
    static isURL(path) {
        return is_url_1.default(path);
    }
}
Utils._config = config_json_1.default;
exports.Utils = Utils;
